(self.webpackChunkdarkdown=self.webpackChunkdarkdown||[]).push([[179],{7879:(t,n,l)=>{"use strict";l.r(n),l.d(n,{slides:()=>u,backgrounds:()=>p,fragmentSteps:()=>k,fusumaProps:()=>i,default:()=>m});var e=l(7401),a=l(9332);l(108),l(6841);function r(){return r=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var l=arguments[n];for(var e in l)Object.prototype.hasOwnProperty.call(l,e)&&(t[e]=l[e])}return t},r.apply(this,arguments)}const u=[t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("p",null,"Markdown を 黒塗りできる Monadic Parser"),(0,a.kt)("h1",null,"Darkdown"),(0,a.kt)("p",null,"@sadnessOjisan")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"⚠️ この発表は政権批判の意図はなく、政治に対する何かしらの主張は含みません。")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"About Me"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ついに就職した。"),(0,a.kt)("li",{parentName:"ul"},"Iris LT のことをクソアプリコンテストと思ってる"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"行政文書に Markdown !?"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://twitter.com/hal_sk/status/1432849899553394691"},"https://twitter.com/hal_sk/status/1432849899553394691")))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"僕も賛成"),(0,a.kt)("p",null,"plain text は差分がわかりやすい")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"ここでクイズです")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"行政文書に必要な機能はなんでしょうか？")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"正解は、■■■ です。")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"正解は、黒塗り です。")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"黒塗りは必要"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"都合の悪い情報を隠すため？"),(0,a.kt)("li",{parentName:"ul"},"個人情報が含まれる"),(0,a.kt)("li",{parentName:"ul"},"攻撃に使われる"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"黒塗りできるマークダウン言語を作ろう")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"政府のための要件を考える"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"対象は plain text"),(0,a.kt)("li",{parentName:"ul"},"黒塗りできる文法を定義する"),(0,a.kt)("li",{parentName:"ul"},"3rd party のライブラリを使ってはいけない"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"Parser を自作しよう")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"OCaml で実装する"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"演算子の定義ができる"),(0,a.kt)("li",{parentName:"ul"},"組み込みの Result 型がある",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"parser の失敗を検知する必要がある"))),(0,a.kt)("li",{parentName:"ul"},"引数の適用がやりやすい"),(0,a.kt)("li",{parentName:"ul"},"俺は Haskell が書けない"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"Parser Combinator とは"),(0,a.kt)("p",null,"パーサー を コンビネーション する")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"Parser の定義"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"type input = { text : string; pos : int }\n\n\ntype parser_t = input -> input * ('a, string) result;\n")),(0,a.kt)("br",null),(0,a.kt)("p",null,"入力 を受け取り、消費しなかった入力と、パース結果を返す。\n消費しなかった入力を返すのは、後続の parser に渡すため。"),(0,a.kt)("p",null,"例: 最小限のパーサー"),(0,a.kt)("p",null,"文字列の先頭一文字をパースする。"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let get_char = function\n  | [] -> None\n  | c::cs -> Some (c, cs)\n")),(0,a.kt)("p",null,"FYI: ",(0,a.kt)("a",{parentName:"p",href:"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"},"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"コンビネーターを作る"),(0,a.kt)("p",null,"パーサーが次の 3 つの性質を満たすようにする"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"functor"),(0,a.kt)("li",{parentName:"ul"},"applicative fanctor"),(0,a.kt)("li",{parentName:"ul"},"monad",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"darkdown では実装しない。applicative のみで済むようにズルしてます。"))))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"map"),(0,a.kt)("p",null,"functor.\nパース結果の型を引数にとる関数を組み合わせられる。"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let map (f : 'a -> 'b) (p : 'a parser) : 'b parser =\n{\n    run =\n      (fun input ->\n        match p.run input with\n        | input', Ok x -> (input', Ok (f x))\n        | input', Error error -> (input', Error error));\n  }\n\nlet ( <$> ) = map\n")),(0,a.kt)("p",null,"例: string を返す parser から、 AST に変換する parser を作り出せる"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},'let h1_parse =\n  map\n    (fun x -> { kind = "h1"; content = x })\n    (prefix "# " *> parse_while (fun x -> not (is_space x)))\n'))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,(0,a.kt)("inlineCode",{parentName:"h2"},"*>"),", ",(0,a.kt)("inlineCode",{parentName:"h2"},"<*")),(0,a.kt)("p",null,"複数のパーサーの結果を組み合わせられる。連接コンビネーター (applicative) ",(0,a.kt)("inlineCode",{parentName:"p"},"<*>")," から作ることが多いが、単体でも定義できる。"),(0,a.kt)("p",null,"口が開いている方を捨てられる"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( *> ) (p1 : 'a parser) (p2 : 'b parser) : 'b parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok _ -> p2.run input'\n        | Error e -> (input', Error e));\n  }\n\n\nlet ( <* ) (p1 : 'a parser) (p2 : 'b parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (\n            let input'', result' = p2.run input' in\n            match result' with\n            | Ok _ -> (input'', Ok x)\n            | Error e -> (input'', Error e))\n        | Error e -> (input', Error e));\n  }\n")),(0,a.kt)("p",null,"例: ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," で囲まれた中身を取り出せる"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let kakko_parse: string parser =\n  prefix \"[\" *> parse_while (fun x -> x != ']') <* any_char\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"[")," の左と ",(0,a.kt)("inlineCode",{parentName:"p"},"]")," の右を捨てている")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h2",null,"選択パーサー"),(0,a.kt)("p",null,"alternative と呼ばれているもの。"),(0,a.kt)("p",null,"複数のパーサーがあり、片方が失敗したらもう片方でパースできる。"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( <|> ) (p1 : 'a parser) (p2 : 'a parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (input', Ok x)\n        | Error _ -> p2.run input);\n  }\n"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"ではこれらを使って行政文書を黒塗りしよう")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"LIVE")),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("h1",null,"おわりに"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"今回は Markdown それ自体をパースするのは諦めているので簡単な実装"),(0,a.kt)("li",{parentName:"ul"},"ちゃんとしようとするとめちゃくちゃ大変なことになりそう. 引用ブロックやリストブロックが厄介すぎて投げた"),(0,a.kt)("li",{parentName:"ul"},"ちなみに Haskell だと Parsec というライブラリを使った例がゴロゴロ転がっています"),(0,a.kt)("li",{parentName:"ul"},"完全な Markdown Parser を OCaml で作ることを最近の日課にしてるので、一緒に作ってくれる人がいましたら是非"))),t=>(0,a.kt)(e.Fragment,null,(0,a.kt)("p",null,"参考資料"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"},"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=Y5IIXUBXvLs"},"https://www.youtube.com/watch?v=Y5IIXUBXvLs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.lambdanote.com/products/haskell"},"https://www.lambdanote.com/products/haskell"))))],p=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],k=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=[{classes:"title"},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}],s={};function m({components:t,...n}){return(0,a.kt)("wrapper",r({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Markdown を 黒塗りできる Monadic Parser"),(0,a.kt)("h1",null,"Darkdown"),(0,a.kt)("p",null,"@sadnessOjisan"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"⚠️ この発表は政権批判の意図はなく、政治に対する何かしらの主張は含みません。"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"About Me"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ついに就職した。"),(0,a.kt)("li",{parentName:"ul"},"Iris LT のことをクソアプリコンテストと思ってる")),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"行政文書に Markdown !?"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://twitter.com/hal_sk/status/1432849899553394691"},"https://twitter.com/hal_sk/status/1432849899553394691"))),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"僕も賛成"),(0,a.kt)("p",null,"plain text は差分がわかりやすい"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"ここでクイズです"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"行政文書に必要な機能はなんでしょうか？"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"正解は、■■■ です。"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"正解は、黒塗り です。"),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"黒塗りは必要"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"都合の悪い情報を隠すため？"),(0,a.kt)("li",{parentName:"ul"},"個人情報が含まれる"),(0,a.kt)("li",{parentName:"ul"},"攻撃に使われる")),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"黒塗りできるマークダウン言語を作ろう"),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"政府のための要件を考える"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"対象は plain text"),(0,a.kt)("li",{parentName:"ul"},"黒塗りできる文法を定義する"),(0,a.kt)("li",{parentName:"ul"},"3rd party のライブラリを使ってはいけない")),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"Parser を自作しよう"),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"OCaml で実装する"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"演算子の定義ができる"),(0,a.kt)("li",{parentName:"ul"},"組み込みの Result 型がある",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"parser の失敗を検知する必要がある"))),(0,a.kt)("li",{parentName:"ul"},"引数の適用がやりやすい"),(0,a.kt)("li",{parentName:"ul"},"俺は Haskell が書けない")),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"Parser Combinator とは"),(0,a.kt)("p",null,"パーサー を コンビネーション する"),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"Parser の定義"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"type input = { text : string; pos : int }\n\n\ntype parser_t = input -> input * ('a, string) result;\n")),(0,a.kt)("br",null),(0,a.kt)("p",null,"入力 を受け取り、消費しなかった入力と、パース結果を返す。\n消費しなかった入力を返すのは、後続の parser に渡すため。"),(0,a.kt)("p",null,"例: 最小限のパーサー"),(0,a.kt)("p",null,"文字列の先頭一文字をパースする。"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let get_char = function\n  | [] -> None\n  | c::cs -> Some (c, cs)\n")),(0,a.kt)("p",null,"FYI: ",(0,a.kt)("a",{parentName:"p",href:"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"},"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514")),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"コンビネーターを作る"),(0,a.kt)("p",null,"パーサーが次の 3 つの性質を満たすようにする"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"functor"),(0,a.kt)("li",{parentName:"ul"},"applicative fanctor"),(0,a.kt)("li",{parentName:"ul"},"monad",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"darkdown では実装しない。applicative のみで済むようにズルしてます。")))),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"map"),(0,a.kt)("p",null,"functor.\nパース結果の型を引数にとる関数を組み合わせられる。"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let map (f : 'a -> 'b) (p : 'a parser) : 'b parser =\n{\n    run =\n      (fun input ->\n        match p.run input with\n        | input', Ok x -> (input', Ok (f x))\n        | input', Error error -> (input', Error error));\n  }\n\nlet ( <$> ) = map\n")),(0,a.kt)("p",null,"例: string を返す parser から、 AST に変換する parser を作り出せる"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},'let h1_parse =\n  map\n    (fun x -> { kind = "h1"; content = x })\n    (prefix "# " *> parse_while (fun x -> not (is_space x)))\n')),(0,a.kt)("hr",null),(0,a.kt)("h2",null,(0,a.kt)("inlineCode",{parentName:"h2"},"*>"),", ",(0,a.kt)("inlineCode",{parentName:"h2"},"<*")),(0,a.kt)("p",null,"複数のパーサーの結果を組み合わせられる。連接コンビネーター (applicative) ",(0,a.kt)("inlineCode",{parentName:"p"},"<*>")," から作ることが多いが、単体でも定義できる。"),(0,a.kt)("p",null,"口が開いている方を捨てられる"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( *> ) (p1 : 'a parser) (p2 : 'b parser) : 'b parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok _ -> p2.run input'\n        | Error e -> (input', Error e));\n  }\n\n\nlet ( <* ) (p1 : 'a parser) (p2 : 'b parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (\n            let input'', result' = p2.run input' in\n            match result' with\n            | Ok _ -> (input'', Ok x)\n            | Error e -> (input'', Error e))\n        | Error e -> (input', Error e));\n  }\n")),(0,a.kt)("p",null,"例: ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," で囲まれた中身を取り出せる"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let kakko_parse: string parser =\n  prefix \"[\" *> parse_while (fun x -> x != ']') <* any_char\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"[")," の左と ",(0,a.kt)("inlineCode",{parentName:"p"},"]")," の右を捨てている"),(0,a.kt)("hr",null),(0,a.kt)("h2",null,"選択パーサー"),(0,a.kt)("p",null,"alternative と呼ばれているもの。"),(0,a.kt)("p",null,"複数のパーサーがあり、片方が失敗したらもう片方でパースできる。"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( <|> ) (p1 : 'a parser) (p2 : 'a parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (input', Ok x)\n        | Error _ -> p2.run input);\n  }\n")),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"ではこれらを使って行政文書を黒塗りしよう"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"LIVE"),(0,a.kt)("hr",null),(0,a.kt)("h1",null,"おわりに"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"今回は Markdown それ自体をパースするのは諦めているので簡単な実装"),(0,a.kt)("li",{parentName:"ul"},"ちゃんとしようとするとめちゃくちゃ大変なことになりそう. 引用ブロックやリストブロックが厄介すぎて投げた"),(0,a.kt)("li",{parentName:"ul"},"ちなみに Haskell だと Parsec というライブラリを使った例がゴロゴロ転がっています"),(0,a.kt)("li",{parentName:"ul"},"完全な Markdown Parser を OCaml で作ることを最近の日課にしてるので、一緒に作ってくれる人がいましたら是非")),(0,a.kt)("hr",null),(0,a.kt)("p",null,"参考資料"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"},"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=Y5IIXUBXvLs"},"https://www.youtube.com/watch?v=Y5IIXUBXvLs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.lambdanote.com/products/haskell"},"https://www.lambdanote.com/products/haskell"))))}m.isMDXComponent=!0},5516:(t,n,l)=>{"use strict";l.r(n)},3447:(t,n,l)=>{var e={"./0-slide.md":7879};function a(t){var n=r(t);return l(n)}function r(t){if(!l.o(e,t)){var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}return e[t]}a.keys=function(){return Object.keys(e)},a.resolve=r,t.exports=a,a.id=3447}},t=>{t.O(0,[179],(()=>{[901,921,626].map(t.E)}),5);var n=n=>t(t.s=n);t.O(0,[736],(()=>(n(7751),n(6905),n(9969))));t.O()}]);