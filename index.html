<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>slide</title><meta property="og:title" content="slide"><meta property="og:type" content="article"><script defer="defer" src="/runtime.47add129c30f5fe81550.bundle.js"></script><script defer="defer" src="/vendor.20135c470a9cf89c455b.bundle.js"></script><script defer="defer" src="/main.5774db15b56347a8e610.bundle.js"></script><link href="/vendor.20135c470a9cf89c455b.css" rel="stylesheet"><link href="/main.5774db15b56347a8e610.css" rel="stylesheet"><link rel="prefetch" as="script" href="/901.4b7a4fb5d2e023f05c6c.bundle.js"><link rel="prefetch" as="script" href="/921.d1191b45680eeb0ed92b.bundle.js"></head><body><div id="root"><div class="swiper-container swiper-container-initialized swiper-container-horizontal swiper-container-pointer-events" id="main-slides"><div class="swiper-pagination"></div><div class="swiper-wrapper" id="swiper-wrapper-0da8a4928c61a108" aria-live="polite" style="transform: translate3d(0px, 0px, 0px);"><div class="swiper-slide swiper-slide-active title" data-hash="slide-1" role="group" aria-label="1 / 24" style="width: 1184px;"><div class="slide-internal-box"><p>Markdown を 黒塗りできる Monadic Parser</p><h1>Darkdown</h1><p>@sadnessOjisan</p></div></div><div class="swiper-slide swiper-slide-next" data-hash="slide-2" role="group" aria-label="2 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>⚠️この発表は政権批判の意図はなく、政治に対する何かしらの主張は含みません。</h1></div></div><div class="swiper-slide" data-hash="slide-3" role="group" aria-label="3 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>About Me</h1><ul><li>ついに就職した。</li><li>Iris LT のことをクソアプリコンテストと思ってる</li></ul></div></div><div class="swiper-slide" data-hash="slide-4" role="group" aria-label="4 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>行政文書に Markdown !?</h2><ul><li><a href="https://twitter.com/hal_sk/status/1432849899553394691">https://twitter.com/hal_sk/status/1432849899553394691</a></li></ul></div></div><div class="swiper-slide" data-hash="slide-5" role="group" aria-label="5 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>僕も賛成</h2><p>plain text は差分がわかりやすい</p></div></div><div class="swiper-slide" data-hash="slide-6" role="group" aria-label="6 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>ここでクイズです</h1></div></div><div class="swiper-slide" data-hash="slide-7" role="group" aria-label="7 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>行政文書に必要な機能はなんでしょうか？</h1></div></div><div class="swiper-slide" data-hash="slide-8" role="group" aria-label="8 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>正解は、■■■ です。</h1></div></div><div class="swiper-slide" data-hash="slide-9" role="group" aria-label="9 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>正解は、黒塗り です。</h1></div></div><div class="swiper-slide" data-hash="slide-10" role="group" aria-label="10 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>黒塗りは必要</h2><ul><li>都合の悪い情報を隠すため？</li><li>個人情報が含まれる</li><li>攻撃に使われる</li></ul></div></div><div class="swiper-slide" data-hash="slide-11" role="group" aria-label="11 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>黒塗りできるマークダウン言語を作ろう</h1></div></div><div class="swiper-slide" data-hash="slide-12" role="group" aria-label="12 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>政府のための要件を考える</h2><ul><li>対象はplain text</li><li>黒塗りできる文法を定義する</li><li>3rd party のライブラリを使ってはいけない</li></ul></div></div><div class="swiper-slide" data-hash="slide-13" role="group" aria-label="13 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>Parser を自作しよう</h1></div></div><div class="swiper-slide" data-hash="slide-14" role="group" aria-label="14 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>Parser Combinator VS Parser Generator</h2><p>前述の縛りがあるので　Parser Combinator</p></div></div><div class="swiper-slide" data-hash="slide-15" role="group" aria-label="15 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>OCaml で実装する</h2><ul><li>演算子の定義ができる</li><li>組み込みの Result 型がある<ul><li>parser の失敗を検知する必要がある</li></ul></li><li>引数の適用がやりやすい</li><li>俺は Haskell が書けない</li></ul></div></div><div class="swiper-slide" data-hash="slide-16" role="group" aria-label="16 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>Parser Combinator とは</h2><p>パーサー を コンビネーション する</p></div></div><div class="swiper-slide" data-hash="slide-17" role="group" aria-label="17 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>Parser の定義</h2><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">type</span> input <span class="token operator">=</span> <span class="token punctuation">{</span> text <span class="token punctuation">:</span> string<span class="token punctuation">;</span> pos <span class="token punctuation">:</span> int <span class="token punctuation">}</span>


<span class="token keyword">type</span> parser_t <span class="token operator">=</span> input <span class="token operator">-&gt;</span> input <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token type-variable function">'a</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span> result<span class="token punctuation">;</span>
</code></pre><br><p>入力 を受け取り、消費しなかった入力と、パース結果を返す。
消費しなかった入力を返すのは、後続の parser に渡すため。</p><p>例: 最小限のパーサー</p><p>文字列の先頭一文字をパースする。</p><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">let</span> get_char <span class="token operator">=</span> <span class="token keyword">function</span>
  <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token module variable">None</span>
  <span class="token operator">|</span> c<span class="token punctuation">:</span><span class="token punctuation">:</span>cs <span class="token operator">-&gt;</span> <span class="token module variable">Some</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span> cs<span class="token punctuation">)</span>
</code></pre><p>FYI: <a href="https://zehnpaard.hatenablog.com/entry/2019/07/05/090514">https://zehnpaard.hatenablog.com/entry/2019/07/05/090514</a></p></div></div><div class="swiper-slide" data-hash="slide-18" role="group" aria-label="18 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>コンビネーターを作る</h2><p>パーサーが次の3つの性質を満たすようにする</p><ul><li>functor</li><li>applicative fanctor</li><li>monad<ul><li>darkdown では実装しない。applicative のみで済むようにズルしてます。</li></ul></li></ul></div></div><div class="swiper-slide" data-hash="slide-19" role="group" aria-label="19 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>map</h2><p>functor.
パース結果の型を引数にとる関数を組み合わせられる。</p><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">let</span> map <span class="token punctuation">(</span>f <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> <span class="token operator">-&gt;</span> <span class="token type-variable function">'b</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>p <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token type-variable function">'b</span> parser <span class="token operator">=</span>
<span class="token punctuation">{</span>
    run <span class="token operator">=</span>
      <span class="token punctuation">(</span><span class="token keyword">fun</span> input <span class="token operator">-&gt;</span>
        <span class="token keyword">match</span> p<span class="token punctuation">.</span>run input <span class="token keyword">with</span>
        <span class="token operator">|</span> input'<span class="token punctuation">,</span> <span class="token module variable">Ok</span> x <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input'<span class="token punctuation">,</span> <span class="token module variable">Ok</span> <span class="token punctuation">(</span>f x<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> input'<span class="token punctuation">,</span> <span class="token module variable">Error</span> error <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input'<span class="token punctuation">,</span> <span class="token module variable">Error</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token punctuation">(</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> map
</code></pre><p>例: string を返す parser から、 AST に変換する parser を作り出せる</p><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">let</span> h1_parse <span class="token operator">=</span>
  map
    <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> kind <span class="token operator">=</span> <span class="token string">"h1"</span><span class="token punctuation">;</span> content <span class="token operator">=</span> x <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span>prefix <span class="token string">"# "</span> <span class="token operator">*&gt;</span> parse_while <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-&gt;</span> not <span class="token punctuation">(</span>is_space x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></div><div class="swiper-slide" data-hash="slide-20" role="group" aria-label="20 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2><code>*&gt;</code>, <code>&lt;*</code></h2><p>複数のパーサーの結果を組み合わせられる。連接コンビネーター (applicative) <code>&lt;*&gt;</code> から作ることが多いが、単体でも定義できる。</p><p>口が開いている方を捨てられる</p><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span> <span class="token operator">*&gt;</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>p1 <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser<span class="token punctuation">)</span> <span class="token punctuation">(</span>p2 <span class="token punctuation">:</span> <span class="token type-variable function">'b</span> parser<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token type-variable function">'b</span> parser <span class="token operator">=</span>
  <span class="token punctuation">{</span>
    run <span class="token operator">=</span>
      <span class="token punctuation">(</span><span class="token keyword">fun</span> input <span class="token operator">-&gt;</span>
        <span class="token keyword">let</span> input'<span class="token punctuation">,</span> result <span class="token operator">=</span> p1<span class="token punctuation">.</span>run input <span class="token keyword">in</span>
        <span class="token keyword">match</span> result <span class="token keyword">with</span>
        <span class="token operator">|</span> <span class="token module variable">Ok</span> <span class="token punctuation">_</span> <span class="token operator">-&gt;</span> p2<span class="token punctuation">.</span>run input'
        <span class="token operator">|</span> <span class="token module variable">Error</span> e <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input'<span class="token punctuation">,</span> <span class="token module variable">Error</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


<span class="token keyword">let</span> <span class="token punctuation">(</span> <span class="token operator">&lt;*</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>p1 <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser<span class="token punctuation">)</span> <span class="token punctuation">(</span>p2 <span class="token punctuation">:</span> <span class="token type-variable function">'b</span> parser<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser <span class="token operator">=</span>
  <span class="token punctuation">{</span>
    run <span class="token operator">=</span>
      <span class="token punctuation">(</span><span class="token keyword">fun</span> input <span class="token operator">-&gt;</span>
        <span class="token keyword">let</span> input'<span class="token punctuation">,</span> result <span class="token operator">=</span> p1<span class="token punctuation">.</span>run input <span class="token keyword">in</span>
        <span class="token keyword">match</span> result <span class="token keyword">with</span>
        <span class="token operator">|</span> <span class="token module variable">Ok</span> x <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>
            <span class="token keyword">let</span> input''<span class="token punctuation">,</span> result' <span class="token operator">=</span> p2<span class="token punctuation">.</span>run input' <span class="token keyword">in</span>
            <span class="token keyword">match</span> result' <span class="token keyword">with</span>
            <span class="token operator">|</span> <span class="token module variable">Ok</span> <span class="token punctuation">_</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input''<span class="token punctuation">,</span> <span class="token module variable">Ok</span> x<span class="token punctuation">)</span>
            <span class="token operator">|</span> <span class="token module variable">Error</span> e <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input''<span class="token punctuation">,</span> <span class="token module variable">Error</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token module variable">Error</span> e <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input'<span class="token punctuation">,</span> <span class="token module variable">Error</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><p>例: <code>[]</code> で囲まれた中身を取り出せる</p><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">let</span> kakko_parse<span class="token punctuation">:</span> string parser <span class="token operator">=</span>
  prefix <span class="token string">"["</span> <span class="token operator">*&gt;</span> parse_while <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-&gt;</span> x <span class="token operator">!=</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token operator">&lt;*</span> any_char
</code></pre><p><code>[</code> の左と <code>]</code> の右を捨てている</p></div></div><div class="swiper-slide" data-hash="slide-21" role="group" aria-label="21 / 24" style="width: 1184px;"><div class="slide-internal-box"><h2>選択パーサー</h2><p>alternativeと呼ばれているもの。</p><p>複数のパーサーがあり、片方が失敗したらもう片方でパースできる。</p><pre class="  language-ocaml" tabindex="0"><code class="  language-ocaml"><span class="token keyword">let</span> <span class="token punctuation">(</span> <span class="token operator">&lt;|&gt;</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>p1 <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser<span class="token punctuation">)</span> <span class="token punctuation">(</span>p2 <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token type-variable function">'a</span> parser <span class="token operator">=</span>
  <span class="token punctuation">{</span>
    run <span class="token operator">=</span>
      <span class="token punctuation">(</span><span class="token keyword">fun</span> input <span class="token operator">-&gt;</span>
        <span class="token keyword">let</span> input'<span class="token punctuation">,</span> result <span class="token operator">=</span> p1<span class="token punctuation">.</span>run input <span class="token keyword">in</span>
        <span class="token keyword">match</span> result <span class="token keyword">with</span>
        <span class="token operator">|</span> <span class="token module variable">Ok</span> x <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>input'<span class="token punctuation">,</span> <span class="token module variable">Ok</span> x<span class="token punctuation">)</span>
        <span class="token operator">|</span> <span class="token module variable">Error</span> <span class="token punctuation">_</span> <span class="token operator">-&gt;</span> p2<span class="token punctuation">.</span>run input<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div></div><div class="swiper-slide" data-hash="slide-22" role="group" aria-label="22 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>ではこれらを使って行政文書を黒塗りしよう</h1></div></div><div class="swiper-slide" data-hash="slide-23" role="group" aria-label="23 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>LIVE</h1></div></div><div class="swiper-slide" data-hash="slide-24" role="group" aria-label="24 / 24" style="width: 1184px;"><div class="slide-internal-box"><h1>おわりに</h1><ul><li>今回はMarkdown それ自体をパースするのは諦めているので簡単な実装</li><li>ちゃんとしようとするとめちゃくちゃ大変なことになりそう. 引用ブロックやリストブロックが厄介すぎて投げた</li><li>ちなみに Haskell だと Parsec というライブラリを使った例がゴロゴロ転がっています</li><li>完全な Markdown Parser を OCaml で作ることを最近の日課にしてるので、一緒に作ってくれる人がいましたら是非</li></ul></div></div></div><span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span></div></div></body></html>