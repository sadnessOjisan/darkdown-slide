(self.webpackChunkdarkdown=self.webpackChunkdarkdown||[]).push([[179],{7879:(n,t,l)=>{"use strict";l.r(t),l.d(t,{slides:()=>u,backgrounds:()=>p,fragmentSteps:()=>k,fusumaProps:()=>i,default:()=>m});var e=l(7401),r=l(9332);l(108),l(6841);function a(){return a=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var l=arguments[t];for(var e in l)Object.prototype.hasOwnProperty.call(l,e)&&(n[e]=l[e])}return n},a.apply(this,arguments)}const u=[n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("p",null,"Markdown を 黒塗りできる Monadic Parser"),(0,r.kt)("h1",null,"Darkdown"),(0,r.kt)("p",null,"@sadnessOjisan")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"⚠️この発表は政権批判の意図はなく、政治に対する何かしらの主張は含みません。")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"About Me"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ついに就職した。"),(0,r.kt)("li",{parentName:"ul"},"Iris LT のことをクソアプリコンテストと思ってる"))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"行政文書に Markdown !?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://twitter.com/hal_sk/status/1432849899553394691"},"https://twitter.com/hal_sk/status/1432849899553394691")))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"僕も賛成"),(0,r.kt)("p",null,"plain text は差分がわかりやすい")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"ここでクイズです")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"行政文書に必要な機能はなんでしょうか？")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"正解は、■■■ です。")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"正解は、黒塗り です。")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"黒塗りは必要"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"都合の悪い情報を隠すため？"),(0,r.kt)("li",{parentName:"ul"},"個人情報が含まれる"),(0,r.kt)("li",{parentName:"ul"},"攻撃に使われる"))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"黒塗りできるマークダウン言語を作ろう")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"政府のための要件を考える"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"対象はplain text"),(0,r.kt)("li",{parentName:"ul"},"黒塗りできる文法を定義する"),(0,r.kt)("li",{parentName:"ul"},"3rd party のライブラリを使ってはいけない"))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"Parser を自作しよう")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"Parser Combinator VS Parser Generator"),(0,r.kt)("p",null,"前述の縛りがあるので　Parser Combinator")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"OCaml で実装する"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"演算子の定義ができる"),(0,r.kt)("li",{parentName:"ul"},"組み込みの Result 型がある",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"parser の失敗を検知する必要がある"))),(0,r.kt)("li",{parentName:"ul"},"引数の適用がやりやすい"),(0,r.kt)("li",{parentName:"ul"},"俺は Haskell が書けない"))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"Parser Combinator とは"),(0,r.kt)("p",null,"パーサー を コンビネーション する")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"Parser の定義"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type input = { text : string; pos : int }\n\n\ntype parser_t = input -> input * ('a, string) result;\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"入力 を受け取り、消費しなかった入力と、パース結果を返す。\n消費しなかった入力を返すのは、後続の parser に渡すため。"),(0,r.kt)("p",null,"例: 最小限のパーサー"),(0,r.kt)("p",null,"文字列の先頭一文字をパースする。"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let get_char = function\n  | [] -> None\n  | c::cs -> Some (c, cs)\n")),(0,r.kt)("p",null,"FYI: ",(0,r.kt)("a",{parentName:"p",href:"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"},"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"コンビネーターを作る"),(0,r.kt)("p",null,"パーサーが次の3つの性質を満たすようにする"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"functor"),(0,r.kt)("li",{parentName:"ul"},"applicative fanctor"),(0,r.kt)("li",{parentName:"ul"},"monad",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"darkdown では実装しない。applicative のみで済むようにズルしてます。"))))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"map"),(0,r.kt)("p",null,"functor.\nパース結果の型を引数にとる関数を組み合わせられる。"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let map (f : 'a -> 'b) (p : 'a parser) : 'b parser =\n{\n    run =\n      (fun input ->\n        match p.run input with\n        | input', Ok x -> (input', Ok (f x))\n        | input', Error error -> (input', Error error));\n  }\n\nlet ( <$> ) = map\n")),(0,r.kt)("p",null,"例: string を返す parser から、 AST に変換する parser を作り出せる"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'let h1_parse =\n  map\n    (fun x -> { kind = "h1"; content = x })\n    (prefix "# " *> parse_while (fun x -> not (is_space x)))\n'))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,(0,r.kt)("inlineCode",{parentName:"h2"},"*>"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"<*")),(0,r.kt)("p",null,"複数のパーサーの結果を組み合わせられる。連接コンビネーター (applicative) ",(0,r.kt)("inlineCode",{parentName:"p"},"<*>")," から作ることが多いが、単体でも定義できる。"),(0,r.kt)("p",null,"口が開いている方を捨てられる"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( *> ) (p1 : 'a parser) (p2 : 'b parser) : 'b parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok _ -> p2.run input'\n        | Error e -> (input', Error e));\n  }\n\n\nlet ( <* ) (p1 : 'a parser) (p2 : 'b parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (\n            let input'', result' = p2.run input' in\n            match result' with\n            | Ok _ -> (input'', Ok x)\n            | Error e -> (input'', Error e))\n        | Error e -> (input', Error e));\n  }\n")),(0,r.kt)("p",null,"例: ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," で囲まれた中身を取り出せる"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let kakko_parse: string parser =\n  prefix \"[\" *> parse_while (fun x -> x != ']') <* any_char\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[")," の左と ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," の右を捨てている")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h2",null,"選択パーサー"),(0,r.kt)("p",null,"alternativeと呼ばれているもの。"),(0,r.kt)("p",null,"複数のパーサーがあり、片方が失敗したらもう片方でパースできる。"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( <|> ) (p1 : 'a parser) (p2 : 'a parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (input', Ok x)\n        | Error _ -> p2.run input);\n  }\n"))),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"ではこれらを使って行政文書を黒塗りしよう")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"LIVE")),n=>(0,r.kt)(e.Fragment,null,(0,r.kt)("h1",null,"おわりに"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"今回はMarkdown それ自体をパースするのは諦めているので簡単な実装"),(0,r.kt)("li",{parentName:"ul"},"ちゃんとしようとするとめちゃくちゃ大変なことになりそう. 引用ブロックやリストブロックが厄介すぎて投げた"),(0,r.kt)("li",{parentName:"ul"},"ちなみに Haskell だと Parsec というライブラリを使った例がゴロゴロ転がっています"),(0,r.kt)("li",{parentName:"ul"},"完全な Markdown Parser を OCaml で作ることを最近の日課にしてるので、一緒に作ってくれる人がいましたら是非")))],p=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],k=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=[{classes:"title"},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}],s={};function m({components:n,...t}){return(0,r.kt)("wrapper",a({},s,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Markdown を 黒塗りできる Monadic Parser"),(0,r.kt)("h1",null,"Darkdown"),(0,r.kt)("p",null,"@sadnessOjisan"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"⚠️この発表は政権批判の意図はなく、政治に対する何かしらの主張は含みません。"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"About Me"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ついに就職した。"),(0,r.kt)("li",{parentName:"ul"},"Iris LT のことをクソアプリコンテストと思ってる")),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"行政文書に Markdown !?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://twitter.com/hal_sk/status/1432849899553394691"},"https://twitter.com/hal_sk/status/1432849899553394691"))),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"僕も賛成"),(0,r.kt)("p",null,"plain text は差分がわかりやすい"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"ここでクイズです"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"行政文書に必要な機能はなんでしょうか？"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"正解は、■■■ です。"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"正解は、黒塗り です。"),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"黒塗りは必要"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"都合の悪い情報を隠すため？"),(0,r.kt)("li",{parentName:"ul"},"個人情報が含まれる"),(0,r.kt)("li",{parentName:"ul"},"攻撃に使われる")),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"黒塗りできるマークダウン言語を作ろう"),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"政府のための要件を考える"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"対象はplain text"),(0,r.kt)("li",{parentName:"ul"},"黒塗りできる文法を定義する"),(0,r.kt)("li",{parentName:"ul"},"3rd party のライブラリを使ってはいけない")),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"Parser を自作しよう"),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"Parser Combinator VS Parser Generator"),(0,r.kt)("p",null,"前述の縛りがあるので　Parser Combinator"),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"OCaml で実装する"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"演算子の定義ができる"),(0,r.kt)("li",{parentName:"ul"},"組み込みの Result 型がある",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"parser の失敗を検知する必要がある"))),(0,r.kt)("li",{parentName:"ul"},"引数の適用がやりやすい"),(0,r.kt)("li",{parentName:"ul"},"俺は Haskell が書けない")),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"Parser Combinator とは"),(0,r.kt)("p",null,"パーサー を コンビネーション する"),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"Parser の定義"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"type input = { text : string; pos : int }\n\n\ntype parser_t = input -> input * ('a, string) result;\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"入力 を受け取り、消費しなかった入力と、パース結果を返す。\n消費しなかった入力を返すのは、後続の parser に渡すため。"),(0,r.kt)("p",null,"例: 最小限のパーサー"),(0,r.kt)("p",null,"文字列の先頭一文字をパースする。"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let get_char = function\n  | [] -> None\n  | c::cs -> Some (c, cs)\n")),(0,r.kt)("p",null,"FYI: ",(0,r.kt)("a",{parentName:"p",href:"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514"},"https://zehnpaard.hatenablog.com/entry/2019/07/05/090514")),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"コンビネーターを作る"),(0,r.kt)("p",null,"パーサーが次の3つの性質を満たすようにする"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"functor"),(0,r.kt)("li",{parentName:"ul"},"applicative fanctor"),(0,r.kt)("li",{parentName:"ul"},"monad",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"darkdown では実装しない。applicative のみで済むようにズルしてます。")))),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"map"),(0,r.kt)("p",null,"functor.\nパース結果の型を引数にとる関数を組み合わせられる。"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let map (f : 'a -> 'b) (p : 'a parser) : 'b parser =\n{\n    run =\n      (fun input ->\n        match p.run input with\n        | input', Ok x -> (input', Ok (f x))\n        | input', Error error -> (input', Error error));\n  }\n\nlet ( <$> ) = map\n")),(0,r.kt)("p",null,"例: string を返す parser から、 AST に変換する parser を作り出せる"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'let h1_parse =\n  map\n    (fun x -> { kind = "h1"; content = x })\n    (prefix "# " *> parse_while (fun x -> not (is_space x)))\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",null,(0,r.kt)("inlineCode",{parentName:"h2"},"*>"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"<*")),(0,r.kt)("p",null,"複数のパーサーの結果を組み合わせられる。連接コンビネーター (applicative) ",(0,r.kt)("inlineCode",{parentName:"p"},"<*>")," から作ることが多いが、単体でも定義できる。"),(0,r.kt)("p",null,"口が開いている方を捨てられる"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( *> ) (p1 : 'a parser) (p2 : 'b parser) : 'b parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok _ -> p2.run input'\n        | Error e -> (input', Error e));\n  }\n\n\nlet ( <* ) (p1 : 'a parser) (p2 : 'b parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (\n            let input'', result' = p2.run input' in\n            match result' with\n            | Ok _ -> (input'', Ok x)\n            | Error e -> (input'', Error e))\n        | Error e -> (input', Error e));\n  }\n")),(0,r.kt)("p",null,"例: ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," で囲まれた中身を取り出せる"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let kakko_parse: string parser =\n  prefix \"[\" *> parse_while (fun x -> x != ']') <* any_char\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[")," の左と ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," の右を捨てている"),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"選択パーサー"),(0,r.kt)("p",null,"alternativeと呼ばれているもの。"),(0,r.kt)("p",null,"複数のパーサーがあり、片方が失敗したらもう片方でパースできる。"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let ( <|> ) (p1 : 'a parser) (p2 : 'a parser) : 'a parser =\n  {\n    run =\n      (fun input ->\n        let input', result = p1.run input in\n        match result with\n        | Ok x -> (input', Ok x)\n        | Error _ -> p2.run input);\n  }\n")),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"ではこれらを使って行政文書を黒塗りしよう"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"LIVE"),(0,r.kt)("hr",null),(0,r.kt)("h1",null,"おわりに"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"今回はMarkdown それ自体をパースするのは諦めているので簡単な実装"),(0,r.kt)("li",{parentName:"ul"},"ちゃんとしようとするとめちゃくちゃ大変なことになりそう. 引用ブロックやリストブロックが厄介すぎて投げた"),(0,r.kt)("li",{parentName:"ul"},"ちなみに Haskell だと Parsec というライブラリを使った例がゴロゴロ転がっています"),(0,r.kt)("li",{parentName:"ul"},"完全な Markdown Parser を OCaml で作ることを最近の日課にしてるので、一緒に作ってくれる人がいましたら是非")))}m.isMDXComponent=!0},5516:(n,t,l)=>{"use strict";l.r(t)},3447:(n,t,l)=>{var e={"./0-slide.md":7879};function r(n){var t=a(n);return l(t)}function a(n){if(!l.o(e,n)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return e[n]}r.keys=function(){return Object.keys(e)},r.resolve=a,n.exports=r,r.id=3447}},n=>{n.O(0,[179],(()=>{[901,921,626].map(n.E)}),5);var t=t=>n(n.s=t);n.O(0,[736],(()=>(t(7751),t(6905),t(9969))));n.O()}]);